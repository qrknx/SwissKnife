@page "/templates"

@using Blazorise
@using Classeur.Core
@using Classeur.Core.CustomizableStructure

@inject IJSRuntime _js;
@inject IRepository<Template, string> _repository;

<PageTitle>@Title</PageTitle>

<h1>@Title</h1>

<Button Clicked="AddTemplateAsync" Color="Color.Primary">Add template</Button>
<Button Clicked="DeleteTemplateAsync" Color="Color.Danger">Delete template</Button>

<Select TValue="string"
        SelectedValue="_selectedTemplateId"
        SelectedValueChanged="async id => { _selectedTemplateId = id; await UpdateHasChangesAsync(); }"
        role="list">
	@foreach (Template template in _templates ?? Enumerable.Empty<Template>())
	{
		<SelectItem Value="template.Id.ToString()">@template.Name (@($"v{template.Schema.Latest.VersionIndex}"))</SelectItem>
	}
</Select>

@if (_selectedTemplateId != null)
{
	<Button Clicked="@(async () => await _addDialog.ShowAsync(field: null))" Color="Color.Secondary">
		Add field
	</Button>

	<Button Clicked="SaveChangesAsync"
	        Color="Color.Success"
	        Disabled="@(!_hasChanges)"
	        title="@ChangeString">
		Save changes
	</Button>

	<ListGroup>
		@foreach (FieldDescription field in SelectedTemplate.Schema.Latest.Fields)
		{
#pragma warning disable CS8321
		    static string IsEnabledColor(bool yes) => yes ? "text-info" : "text-muted";
#pragma warning restore CS8321

		    bool canMoveUp = CanMove(field, relativeMove: -1, out int upperPosition);
		    bool canMoveDown = CanMove(field, relativeMove: 1, out int lowerPosition);

		    <ListGroupItem Flex="Flex.JustifyContent.Between.AlignItems.Center" title="@field">
                <button @onclick="@(async () => await _editDialog.ShowAsync(field))"
                        class="flex-grow-1 text-start border-0 bg-transparent"
                        aria-label="Edit field">
                    @field.Label
                </button>

                <span>
                    <button @onclick="@(async () => await MoveAsync(field, upperPosition))"
                            class="border-0 bg-transparent"
                            title="Move field up"
                            disabled="@(!canMoveUp)">
                        <span class="oi oi-arrow-circle-top @IsEnabledColor(canMoveUp)" aria-hidden="true"></span>
                    </button>

                    <button @onclick="@(async () => await MoveAsync(field, lowerPosition))"
                            class="border-0 bg-transparent"
                            title="Move field down"
                            disabled="@(!canMoveDown)">
                        <span class="oi oi-arrow-circle-bottom @IsEnabledColor(canMoveDown)" aria-hidden="true"></span>
                    </button>

                    <button @onclick="@(async () => await RemoveFieldAsync(field))"
                            class="border-0 bg-transparent"
                            title="Remove field">
                        <span class="oi oi-circle-x text-danger" aria-hidden="true"></span>
                    </button>
                </span>
            </ListGroupItem>
		}
	</ListGroup>
}

<Templates_ChangeFieldModal @ref="_addDialog" FieldChanging="@OnFieldAddingAsync" />
<Templates_ChangeFieldModal @ref="_editDialog" FieldChanging="@OnFieldEditingAsync" />

@code {

	private const string Title = "Templates";

	private List<Template>? _templates;
	private Templates_ChangeFieldModal _addDialog = null!;
	private Templates_ChangeFieldModal _editDialog = null!;
	private string? _selectedTemplateId;
	private bool _hasChanges;

	private Template SelectedTemplate
	{
		get => _templates!.First(t => t.Id == IncoherentId.Parse(_selectedTemplateId!));
		set => _templates![_templates.FindIndex(t => t.Id == value.Id)] = value;
	}

	private string ChangeString => _hasChanges
		? string.Join(Environment.NewLine,
		              SelectedTemplate.Schema
		                              .LatestChanges
		                              .Select(c => c.ToString()))
		: "";

	protected override async Task OnInitializedAsync()
	{
		_templates = await _repository.GetAllAsync(CancellationToken.None);
		_selectedTemplateId = _templates.FirstOrDefault()?.Id.ToString();
	}

	private async Task AddTemplateAsync()
	{
		if (await _js.PromptAsync("Enter template name:", CancellationToken.None) is {Length: > 0} name)
		{
			IncoherentId id = IncoherentId.Generate();

			await _repository.InsertAsync(new Template(name,  new StructureSchema(id)), CancellationToken.None);
			_templates = await _repository.GetAllAsync(CancellationToken.None);
			_selectedTemplateId = id.ToString();
			_hasChanges = false;
		}
	}

	private async Task SaveChangesAsync()
	{
		await _repository.UpdateAsync(SelectedTemplate, CancellationToken.None);
		await _js.AlertAsync("Saved!", CancellationToken.None);
		_hasChanges = false;
	}

	private async Task DeleteTemplateAsync()
	{
		IncoherentId id = IncoherentId.Parse(_selectedTemplateId!);
		await _repository.DeleteAsync(id.ToString(), CancellationToken.None);
		await _js.AlertAsync("Deleted!", CancellationToken.None);
		_templates = await _repository.GetAllAsync(CancellationToken.None);
		_selectedTemplateId = _templates.FirstOrDefault()?.Id.ToString();
		await UpdateHasChangesAsync();
	}

	private bool CanMove(FieldDescription field, int relativeMove, out int newPosition)
	{
		newPosition = SelectedTemplate.Schema
		                              .Latest
		                              .Fields.Select((f, i) => (Index: i, Field: f))
		                              .First(x => x.Field.Key == field.Key)
		                              .Index + relativeMove;

		return MathUtils.Intersects(newPosition, min: 0, max: SelectedTemplate.Schema.Latest.TotalFields - 1);
	}

	private async Task MoveAsync(FieldDescription field, int position)
	{
		SelectedTemplate = SelectedTemplate with
		{
			Schema = SelectedTemplate.Schema
			                         .ToLatestVersionMutator()
			                         .MoveField(field.Key,
			                                    position,
			                                    preserveVersion: await HasPendingChangesAsync()),
		};

		await UpdateHasChangesAsync();
	}

	private async Task RemoveFieldAsync(FieldDescription field)
	{
		SelectedTemplate = SelectedTemplate with
		{
			Schema = SelectedTemplate.Schema
			                         .ToLatestVersionMutator()
			                         .RemoveField(field.Key, preserveVersion: await HasPendingChangesAsync()),
		};

		await UpdateHasChangesAsync();
	}

	private async Task OnFieldAddingAsync((FieldDescription?, FieldDescription New) change)
	{
	    FieldDescription field = change.New;

	    await ChangeSelectedTemplateAsync(SelectedTemplate.Schema.Latest.Has(field.Key)
	                                      ? field with
                                            {
                                                Key = field.Key.MakeUnique(SelectedTemplate.Schema
                                                                                           .Latest
                                                                                           .UnorderedFields
                                                                                           .Select(f => f.Key)),
                                            }
	                                      : field);
	    _addDialog.Reset();
	    await UpdateHasChangesAsync();
	}

    private async Task OnFieldEditingAsync((FieldDescription?, FieldDescription New) change)
    {
        await ChangeSelectedTemplateAsync(change.New);
        await _editDialog.CloseAsync();
        await UpdateHasChangesAsync();
    }

    private async Task ChangeSelectedTemplateAsync(FieldDescription field) => SelectedTemplate = SelectedTemplate with
    {
        Schema = SelectedTemplate.Schema
                                 .ToLatestVersionMutator()
                                 .AddField(field, preserveVersion: await HasPendingChangesAsync()),
    };

    private async Task UpdateHasChangesAsync()
	{
		if (_selectedTemplateId != null)
		{
			Template saved = await _repository.GetAsync(_selectedTemplateId, CancellationToken.None);

			_hasChanges = SelectedTemplate.Schema.Latest.VersionIndex != saved.Schema.Latest.VersionIndex;
		}
		else
		{
			_hasChanges = false;
		}
	}

	private async Task<bool> HasPendingChangesAsync()
	{
		Template saved = await _repository.GetAsync(_selectedTemplateId!, CancellationToken.None);
		return saved.Schema.Latest.VersionIndex != SelectedTemplate.Schema.Latest.VersionIndex;
	}

}
