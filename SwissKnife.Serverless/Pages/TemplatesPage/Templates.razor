@page "/templates"

@using Blazorise
@using Classeur.Core
@using Classeur.Core.CustomizableStructure

@inject IJSRuntime _js;
@inject IRepository<StructureSchema, string> _repository;

<PageTitle>@Title</PageTitle>

<h1>@Title</h1>

<Button Clicked="AddTemplateAsync" Color="Color.Primary">Add template</Button>
<Button Clicked="DeleteTemplateAsync" Color="Color.Danger">Delete template</Button>

<Select TValue="string"
        SelectedValue="_selectedTemplateId"
        SelectedValueChanged="async id => { _selectedTemplateId = id; await UpdateHasChangesAsync(); }"
        role="list">
	@foreach (StructureSchema template in _templates ?? Enumerable.Empty<StructureSchema>())
	{
		<SelectItem Value="template.Id.ToString()">@template.Id (@($"v{template.Latest.Version}"))</SelectItem>
	}
</Select>

@if (_selectedTemplateId != null)
{
	<Button Clicked="@(async () => await _addFieldDialog!.Modal.Show())" Color="Color.Secondary">
		Add field
	</Button>

	<Button Clicked="SaveChangesAsync" Color="Color.Success" Disabled="@(!_hasChanges)">Save changes</Button>

	<ListGroup>
		@foreach (FieldDescription field in SelectedTemplate.Latest.Fields)
		{
			<ListGroupItem Flex="Flex.JustifyContent.Between.AlignItems.Center" title="@field">
				@field.Label
				<span>
					@if (CanMove(field, relativeMove: -1, out int upperPosition))
					{
						<button @onclick="@(async () => await MoveAsync(field, upperPosition))"
						        class="border-0 bg-transparent"
						        title="Move field up">
							<span class="oi oi-arrow-circle-top text-info" aria-hidden="true"></span>
						</button>
					}
					@if (CanMove(field, relativeMove: 1, out int lowerPosition))
					{
						<button @onclick="@(async () => await MoveAsync(field, lowerPosition))"
						        class="border-0 bg-transparent"
						        title="Move field down">
							<span class="oi oi-arrow-circle-bottom text-info" aria-hidden="true"></span>
						</button>
					}
					<button @onclick="@(async () => await RemoveFieldAsync(field))"
					        class="border-0 bg-transparent"
					        title="Remove field">
						<span class="oi oi-circle-x text-danger" aria-hidden="true"></span>
					</button>
				</span>
			</ListGroupItem>
		}
	</ListGroup>
}

<Templates_AddFieldModal @ref="_addFieldDialog" FieldAdding="@OnFieldAddingAsync" />

@code {

	private const string Title = "Templates";

	private List<StructureSchema>? _templates;
	private Templates_AddFieldModal? _addFieldDialog;
	private string? _selectedTemplateId;
	private bool _hasChanges;

	private StructureSchema SelectedTemplate
	{
		get => _templates!.First(t => t.Id == IncoherentId.Parse(_selectedTemplateId!));
		set => _templates![_templates.FindIndex(t => t.Id == value.Id)] = value;
	}

	protected override async Task OnInitializedAsync()
	{
		_templates = await _repository.GetAllAsync(CancellationToken.None);
		_selectedTemplateId = _templates.FirstOrDefault()?.Id.ToString();
	}

	private async Task AddTemplateAsync()
	{
		IncoherentId id = IncoherentId.Generate();
		await _repository.InsertAsync(new StructureSchema(id), CancellationToken.None);
		_templates = await _repository.GetAllAsync(CancellationToken.None);
		_selectedTemplateId = id.ToString();
		_hasChanges = false;
	}

	private async Task SaveChangesAsync()
	{
		await _repository.UpdateAsync(SelectedTemplate, CancellationToken.None);
		await _js.AlertAsync("Saved!", CancellationToken.None);
		_hasChanges = false;
	}

	private async Task DeleteTemplateAsync()
	{
		IncoherentId id = IncoherentId.Parse(_selectedTemplateId!);
		await _repository.DeleteAsync(id.ToString(), CancellationToken.None);
		await _js.AlertAsync("Deleted!", CancellationToken.None);
		_templates = await _repository.GetAllAsync(CancellationToken.None);
		_selectedTemplateId = _templates.FirstOrDefault()?.Id.ToString();
		await UpdateHasChangesAsync();
	}

	private bool CanMove(FieldDescription field, int relativeMove, out int newPosition)
	{
		newPosition = SelectedTemplate.Latest
		                              .Fields.Select((f, i) => (Index: i, Field: f))
		                              .First(x => x.Field.Key == field.Key)
		                              .Index + relativeMove;

		return MathUtils.Intersects(newPosition, min: 0, max: SelectedTemplate.Latest.TotalFields - 1);
	}

	private async Task MoveAsync(FieldDescription field, int position)
	{
		SelectedTemplate = SelectedTemplate.ToLatestVersionMutator()
		                                   .MoveField(field.Key,
		                                              position,
		                                              preserveVersion: await HasPendingChangesAsync());
		await UpdateHasChangesAsync();
	}

	private async Task RemoveFieldAsync(FieldDescription field)
	{
		SelectedTemplate = SelectedTemplate.ToLatestVersionMutator()
		                                   .RemoveField(field.Key, preserveVersion: await HasPendingChangesAsync());
		await UpdateHasChangesAsync();
	}

	private async Task OnFieldAddingAsync(FieldDescription field)
	{
		SelectedTemplate = SelectedTemplate.ToLatestVersionMutator()
		                                   .AddField(field, preserveVersion: await HasPendingChangesAsync())
		                                   .Schema;
		_addFieldDialog!.ResetLabel();
		await UpdateHasChangesAsync();
	}

	private async Task UpdateHasChangesAsync()
	{
		if (_selectedTemplateId != null)
		{
			StructureSchema saved = await _repository.GetAsync(_selectedTemplateId, CancellationToken.None);

			_hasChanges = SelectedTemplate.Latest.Version != saved.Latest.Version;
		}
		else
		{
			_hasChanges = false;
		}
	}

	private async Task<bool> HasPendingChangesAsync()
	{
		StructureSchema saved = await _repository.GetAsync(_selectedTemplateId!, CancellationToken.None);
		return saved.Latest.Version != SelectedTemplate.Latest.Version;
	}

}
