@page "/templates"

@using Blazorise
@using Classeur.Core
@using Classeur.Core.CustomizableStructure

@inject IJSRuntime _js;
@inject IRepository<Template, string> _repository;

<PageTitle>@Title</PageTitle>

<h1>@Title</h1>

<Button Clicked="AddTemplateAsync" Color="Color.Primary">Add template</Button>
<Button Clicked="DeleteTemplateAsync" Color="Color.Danger">Delete template</Button>

<Select TValue="string"
        SelectedValue="_selectedTemplateId"
        SelectedValueChanged="async id => { _selectedTemplateId = id; await UpdateHasChangesAsync(); }"
        role="list">
	@foreach (Template template in _templates ?? Enumerable.Empty<Template>())
	{
		<SelectItem Value="template.Id.ToString()">@template.Name (@($"v{template.Schema.Latest.Version}"))</SelectItem>
	}
</Select>

@if (_selectedTemplateId != null)
{
	<Button Clicked="@(async () => await _addFieldDialog!.Modal.Show())" Color="Color.Secondary">
		Add field
	</Button>

	<Button Clicked="SaveChangesAsync"
	        Color="Color.Success"
	        Disabled="@(!_hasChanges)"
	        title="@ChangeString">
		Save changes
	</Button>

	<ListGroup>
		@foreach (FieldDescription field in SelectedTemplate.Schema.Latest.Fields)
		{
			<ListGroupItem Flex="Flex.JustifyContent.Between.AlignItems.Center" title="@field">
				@field.Label
				<span>
					@if (CanMove(field, relativeMove: -1, out int upperPosition))
					{
						<button @onclick="@(async () => await MoveAsync(field, upperPosition))"
						        class="border-0 bg-transparent"
						        title="Move field up">
							<span class="oi oi-arrow-circle-top text-info" aria-hidden="true"></span>
						</button>
					}
					@if (CanMove(field, relativeMove: 1, out int lowerPosition))
					{
						<button @onclick="@(async () => await MoveAsync(field, lowerPosition))"
						        class="border-0 bg-transparent"
						        title="Move field down">
							<span class="oi oi-arrow-circle-bottom text-info" aria-hidden="true"></span>
						</button>
					}
					<button @onclick="@(async () => await RemoveFieldAsync(field))"
					        class="border-0 bg-transparent"
					        title="Remove field">
						<span class="oi oi-circle-x text-danger" aria-hidden="true"></span>
					</button>
				</span>
			</ListGroupItem>
		}
	</ListGroup>
}

<Templates_AddFieldModal @ref="_addFieldDialog" FieldAdding="@OnFieldAddingAsync" />

@code {

	private const string Title = "Templates";

	private List<Template>? _templates;
	private Templates_AddFieldModal? _addFieldDialog;
	private string? _selectedTemplateId;
	private bool _hasChanges;

	private Template SelectedTemplate
	{
		get => _templates!.First(t => t.Id == IncoherentId.Parse(_selectedTemplateId!));
		set => _templates![_templates.FindIndex(t => t.Id == value.Id)] = value;
	}

	private string ChangeString => _hasChanges
		? string.Join(Environment.NewLine,
		              SelectedTemplate.Schema
		                              .Changes
		                              .SkipWhile(c => c.Version < SelectedTemplate.Schema.Latest.Version)
		                              .Select(c => c.ToString()))
		: "";

	protected override async Task OnInitializedAsync()
	{
		_templates = await _repository.GetAllAsync(CancellationToken.None);
		_selectedTemplateId = _templates.FirstOrDefault()?.Id.ToString();
	}

	private async Task AddTemplateAsync()
	{
		if (await _js.PromptAsync("Enter template name:", CancellationToken.None) is {Length: > 0} name)
		{
			IncoherentId id = IncoherentId.Generate();

			await _repository.InsertAsync(new Template(name,  new StructureSchema(id)), CancellationToken.None);
			_templates = await _repository.GetAllAsync(CancellationToken.None);
			_selectedTemplateId = id.ToString();
			_hasChanges = false;
		}
	}

	private async Task SaveChangesAsync()
	{
		await _repository.UpdateAsync(SelectedTemplate, CancellationToken.None);
		await _js.AlertAsync("Saved!", CancellationToken.None);
		_hasChanges = false;
	}

	private async Task DeleteTemplateAsync()
	{
		IncoherentId id = IncoherentId.Parse(_selectedTemplateId!);
		await _repository.DeleteAsync(id.ToString(), CancellationToken.None);
		await _js.AlertAsync("Deleted!", CancellationToken.None);
		_templates = await _repository.GetAllAsync(CancellationToken.None);
		_selectedTemplateId = _templates.FirstOrDefault()?.Id.ToString();
		await UpdateHasChangesAsync();
	}

	private bool CanMove(FieldDescription field, int relativeMove, out int newPosition)
	{
		newPosition = SelectedTemplate.Schema
		                              .Latest
		                              .Fields.Select((f, i) => (Index: i, Field: f))
		                              .First(x => x.Field.Key == field.Key)
		                              .Index + relativeMove;

		return MathUtils.Intersects(newPosition, min: 0, max: SelectedTemplate.Schema.Latest.TotalFields - 1);
	}

	private async Task MoveAsync(FieldDescription field, int position)
	{
		SelectedTemplate = SelectedTemplate with
		{
			Schema = SelectedTemplate.Schema
			                         .ToLatestVersionMutator()
			                         .MoveField(field.Key,
			                                    position,
			                                    preserveVersion: await HasPendingChangesAsync()),
		};

		await UpdateHasChangesAsync();
	}

	private async Task RemoveFieldAsync(FieldDescription field)
	{
		SelectedTemplate = SelectedTemplate with
		{
			Schema = SelectedTemplate.Schema
			                         .ToLatestVersionMutator()
			                         .RemoveField(field.Key, preserveVersion: await HasPendingChangesAsync()),
		};

		await UpdateHasChangesAsync();
	}

	private async Task OnFieldAddingAsync(FieldDescription field)
	{
		SelectedTemplate = SelectedTemplate with
		{
			Schema = SelectedTemplate.Schema
			                         .ToLatestVersionMutator()
			                         .AddField(field, preserveVersion: await HasPendingChangesAsync())
			                         .Schema,
		};
		_addFieldDialog!.ResetLabel();
		await UpdateHasChangesAsync();
	}

	private async Task UpdateHasChangesAsync()
	{
		if (_selectedTemplateId != null)
		{
			Template saved = await _repository.GetAsync(_selectedTemplateId, CancellationToken.None);

			_hasChanges = SelectedTemplate.Schema.Latest.Version != saved.Schema.Latest.Version;
		}
		else
		{
			_hasChanges = false;
		}
	}

	private async Task<bool> HasPendingChangesAsync()
	{
		Template saved = await _repository.GetAsync(_selectedTemplateId!, CancellationToken.None);
		return saved.Schema.Latest.Version != SelectedTemplate.Schema.Latest.Version;
	}

}
